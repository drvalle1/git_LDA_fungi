indicator[[i]]=ind
z[ind]=i/100
n.indicator[i]=length(ind)
}
#gibbs stuff
ngibbs=1000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1,z=z)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
# tmp=sample.vlk(param,jump1$vlk)
# accept1$vlk=accept1$vlk+tmp$accept
# param$vlk=tmp$vlk
# param$theta=convertVtoTheta(param$vlk,ones.nloc)
param$theta=theta.true
param$phi=sample.phi(param)
# param$phi=phi.true
param$break1=sample.break(param)
# param$break1=break1.true[-c(1,length(break1.true))]
param$z=sample.z(param)
# param$z=z.true
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
seq1=(ngibbs*0.8):ngibbs
theta.estim=matrix(colMeans(vec.theta[seq1,]),nloc,ncommun)
boxplot(theta.estim)
seq.comm=1:5
# seq.comm=c(2,4,5,1,3)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
phi.estim=matrix(colMeans(vec.phi[seq1,]),ncommun,nspp)[seq.comm,]
rango=range(phi.estim,phi.true)
plot(phi.true,phi.estim,ylim=rango,xlim=rango)
lines(rango,rango)
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=5
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=1.5,to=nuni+0.5,by=1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
n.indicator=rep(NA,nuni)
z=matrix(NA,nloc,nspp)
for (i in 1:nuni){
cond=dat==uni[i]
ind=which(cond)
indicator[[i]]=ind
z[ind]=i/100
n.indicator[i]=length(ind)
}
#gibbs stuff
ngibbs=1000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1,z=z)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
# tmp=sample.vlk(param,jump1$vlk)
# accept1$vlk=accept1$vlk+tmp$accept
# param$vlk=tmp$vlk
# param$theta=convertVtoTheta(param$vlk,ones.nloc)
param$theta=theta.true
# param$phi=sample.phi(param)
param$phi=phi.true
param$break1=sample.break(param)
# param$break1=break1.true[-c(1,length(break1.true))]
param$z=sample.z(param)
# param$z=z.true
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
rango=range(param$z,z.true)
plot(z.true,param$z,xlim=rango,ylim=rango)
lines(rango,rango)
rango=range(param$break1,break1.true)
plot(break1.true,param$break1,xlim=rango,ylim=rango)
lines(rango,rango)
break1.true
rango=range(param$break1,break1.true)
plot(break1.true[-c(1,length(break1.true))],param$break1,xlim=rango,ylim=rango)
lines(rango,rango)
break2=break1.true[-c(1,length(break1.true))]
rango=range(param$break1,break2)
plot(break2,param$break1,xlim=rango,ylim=rango)
lines(rango,rango)
rango(z.true)
range(z.true)
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=5
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=1.5,to=nuni+0.5,by=1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
n.indicator=rep(NA,nuni)
z=matrix(NA,nloc,nspp)
for (i in 1:nuni){
cond=dat==uni[i]
ind=which(cond)
indicator[[i]]=ind
z[ind]=i/100
n.indicator[i]=length(ind)
}
#gibbs stuff
ngibbs=10000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1,z=z)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
# tmp=sample.vlk(param,jump1$vlk)
# accept1$vlk=accept1$vlk+tmp$accept
# param$vlk=tmp$vlk
# param$theta=convertVtoTheta(param$vlk,ones.nloc)
param$theta=theta.true
# param$phi=sample.phi(param)
param$phi=phi.true
param$break1=sample.break(param)
# param$break1=break1.true[-c(1,length(break1.true))]
param$z=sample.z(param)
# param$z=z.true
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
rm(list=ls(all=TRUE))
set.seed(4)
nloc=1000
nspp=200
ncommun=5
base=floor(nloc/(ncommun-2))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#export theta
setwd('U:\\GIT_models\\git_LDA_fungi')
nome=paste('theta ',ncommun,'.csv',sep='')
write.csv(theta,nome,row.names=F)
#generate phi
phi=matrix(NA,ncommun,nspp)
mu.large=3
mu.small=-3
ind=matrix(rbinom(ncommun*nspp,size=1,prob=0.1),ncommun,nspp)
for (i in 1:ncommun){
ind1=ind[i,]
cond=ind1==1
tmp=rep(NA,nspp)
tmp[cond ]=rnorm(sum( cond),mean=mu.large,sd=1)
tmp[!cond]=rnorm(sum(!cond),mean=mu.small,sd=1)
phi[i,]=tmp
}
image(phi)
phi.true=phi
#how many unique species does each community have?
teste=rep(0,ncommun)
for (i in 1:nspp){
tmp=ind[,i]
if (sum(tmp)==1){
ind1=which(tmp==1)
teste[ind1]=teste[ind1]+1
}
}
#calculate probabilities
medias=theta%*%phi; dim(medias)
z.true=z=matrix(rnorm(nloc*nspp,mean=medias,sd=1),nloc,nspp)
#generate actual observations y
range(z)
break1.true=break1=c(-Inf,seq(from=-7,to=5.5,by=0.5),Inf)
y=matrix(NA,nloc,nspp)
for (i in 2:length(break1)){
cond=z>break1[i-1] & z<break1[i]
y[cond]=i-2
}
tmp=table(y); tmp; length(tmp); length(break1)
nome=paste('fake data',ncommun,'.csv',sep='')
write.csv(y,nome,row.names=F)
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=5
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=-0.1,to=0.1,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
n.indicator=rep(NA,nuni)
z=matrix(NA,nloc,nspp)
for (i in 1:nuni){
cond=dat==uni[i]
ind=which(cond)
indicator[[i]]=ind
z[ind]=i/100
n.indicator[i]=length(ind)
}
#gibbs stuff
ngibbs=10000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1),break1=rep(1,nuni-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1),break1=rep(0,nuni-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1,z=z)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
tmp=sample.vlk(param,jump1$vlk)
accept1$vlk=accept1$vlk+tmp$accept
param$vlk=tmp$vlk
param$theta=convertVtoTheta(param$vlk,ones.nloc)
# param$theta=theta.true
param$phi=sample.phi(param)
# param$phi=phi.true
tmp=sample.break(param,jump1$break1)
accept1$break1=accept1$break1+tmp$accept
param$break1=tmp$break1
# param$break1=break1.true[-c(1,length(break1.true))]
param$z=sample.z(param)
# param$z=z.true
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
seq1=(ngibbs*0.8):ngibbs
theta.estim=matrix(colMeans(vec.theta[seq1,]),nloc,ncommun)
boxplot(theta.estim)
seq.comm=1:5
# seq.comm=c(2,4,5,1,3)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=c(2,3,4,5,1)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
#look at phi
phi.estim=matrix(colMeans(vec.phi[seq1,]),ncommun,nspp)[seq.comm,]
rango=range(phi.estim,phi.true)
plot(phi.true,phi.estim,ylim=rango,xlim=rango)
lines(rango,rango)
rango=range(param$z,z.true)
plot(z.true,param$z,xlim=rango,ylim=rango)
lines(rango,rango)
phi.estim=matrix(colMeans(vec.phi[seq1,]),ncommun,nspp)[seq.comm,]
rango=range(phi.estim,phi.true)
plot(phi.true,phi.estim,ylim=rango,xlim=rango)
lines(rango,rango)
seq.comm=c(2,3,4,5,1)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=10
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=-0.1,to=0.1,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
n.indicator=rep(NA,nuni)
z=matrix(NA,nloc,nspp)
for (i in 1:nuni){
cond=dat==uni[i]
ind=which(cond)
indicator[[i]]=ind
z[ind]=i/100
n.indicator[i]=length(ind)
}
#gibbs stuff
ngibbs=10000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1),break1=rep(1,nuni-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1),break1=rep(0,nuni-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1,z=z)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
tmp=sample.vlk(param,jump1$vlk)
accept1$vlk=accept1$vlk+tmp$accept
param$vlk=tmp$vlk
param$theta=convertVtoTheta(param$vlk,ones.nloc)
# param$theta=theta.true
param$phi=sample.phi(param)
# param$phi=phi.true
tmp=sample.break(param,jump1$break1)
accept1$break1=accept1$break1+tmp$accept
param$break1=tmp$break1
# param$break1=break1.true[-c(1,length(break1.true))]
param$z=sample.z(param)
# param$z=z.true
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
seq1=(ngibbs*0.8):ngibbs
theta.estim=matrix(colMeans(vec.theta[seq1,]),nloc,ncommun)
boxplot(theta.estim)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=c(2,5,1,4,3)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=1:5
# seq.comm=c(2,5,1,4,3)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=1:5
# seq.comm=c(2,5,1,4,3)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=c(3,5,1,4,2)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=1:5
# seq.comm=c(3,5,1,4,2)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=c(3,1,2,5,4)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
phi.estim=matrix(colMeans(vec.phi[seq1,]),ncommun,nspp)[seq.comm,]
rango=range(phi.estim,phi.true)
plot(phi.true,phi.estim,ylim=rango,xlim=rango)
lines(rango,rango)
#look at z
rango=range(param$z,z.true)
plot(z.true,param$z,xlim=rango,ylim=rango)
lines(rango,rango)
break2=break1.true[-c(1,length(break1.true))]
rango=range(param$break1,break2)
plot(break2,param$break1,xlim=rango,ylim=rango)
lines(rango,rango)
