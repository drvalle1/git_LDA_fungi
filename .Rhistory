k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
jump=jump1$vlk
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=10
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=-2,to=2,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
for (i in 1:nuni){
cond=dat==uni[i]
indicator[[i]]=which(cond)
}
#gibbs stuff
ngibbs=10000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1),
phi=matrix(1,ncommun,nspp),
break1=rep(1,nuni-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1),
phi=matrix(0,ncommun,nspp),
break1=rep(0,nuni-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
tmp=sample.vlk(param,jump1$vlk)
accept1$vlk=accept1$vlk+tmp$accept
param$vlk=tmp$vlk
param$theta=convertVtoTheta(param$vlk,ones.nloc)
# param$theta=theta.true
tmp=sample.phi(param,jump1$phi)
accept1$phi=accept1$phi+tmp$accept
param$phi=tmp$phi
# param$phi=phi.true
tmp=sample.break(param,jump1$break1)
accept1$break1=accept1$break1+tmp$accept
param$break1=tmp$break1
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
jump=jump1$vlk
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=10
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=-2,to=2,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
for (i in 1:nuni){
cond=dat==uni[i]
indicator[[i]]=which(cond)
}
#gibbs stuff
ngibbs=10000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1),
phi=matrix(1,ncommun,nspp),
break1=rep(1,nuni-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1),
phi=matrix(0,ncommun,nspp),
break1=rep(0,nuni-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1)
#core MCMC algorithm
options(warn=2)
for (i in 1:166){#ngibbs){
print(i)
tmp=sample.vlk(param,jump1$vlk)
accept1$vlk=accept1$vlk+tmp$accept
param$vlk=tmp$vlk
param$theta=convertVtoTheta(param$vlk,ones.nloc)
# param$theta=theta.true
tmp=sample.phi(param,jump1$phi)
accept1$phi=accept1$phi+tmp$accept
param$phi=tmp$phi
# param$phi=phi.true
tmp=sample.break(param,jump1$break1)
accept1$break1=accept1$break1+tmp$accept
param$break1=tmp$break1
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
jump=jump1$vlk
vlk.orig=vlk.old=param$vlk
#things for MH
tmp=tnorm(n.vlk,lo=lo.vlk,hi=hi.vlk,mu=vlk.old[,-ncommun],sig=jump)
vlk.prop=matrix(tmp,nloc,ncommun-1)
tmp=fix.MH(lo=lo.vlk,hi=hi.vlk,old1=vlk.old[,-ncommun],new1=vlk.prop,jump)
fix1=matrix(tmp,nloc,ncommun-1)
#priors
prior.old=dbeta(vlk.old[,-ncommun],1,gamma,log=T)
prior.new=dbeta(vlk.prop,1,gamma,log=T)
for (i in 1:(ncommun-1)){
vlk.new=vlk.old
vlk.new[,i]=vlk.prop[,i]
theta.old=convertVtoTheta(vlk.old,ones.nloc)
theta.new=convertVtoTheta(vlk.new,ones.nloc)
pold=get.logl(theta.old,param$phi,param$break1)
pnew=get.logl(theta.new,param$phi,param$break1)
pold1=(pold%*%ones.nspp)+prior.old[,i]
pnew1=(pnew%*%ones.nspp)+prior.new[,i]
k=acceptMH(pold1,pnew1+fix1[,i],vlk.old[,i],vlk.new[,i],F)
vlk.old[,i]=k$x
}
i
pold
get.logl(theta.new,param$phi,param$break1)
range(theta.new)
theta=theta.new
phi=param$phi
break1=param$break1
media=theta%*%phi
break2=c(-Inf,break1,Inf)
prob=matrix(NA,nloc,nspp)
for (i in 1:nuni){
ind=indicator[[i]]
media1=media[ind]
prob[ind]=pnorm(break2[i+1]-media1)-pnorm(break2[i]-media1)
}
log(prob)
range(prob)
1e-16
log(1e-16)
prob[prob < 1e-16]=1e-16
log(prob)
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=10
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=-2,to=2,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
for (i in 1:nuni){
cond=dat==uni[i]
indicator[[i]]=which(cond)
}
#gibbs stuff
ngibbs=10000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1),
phi=matrix(1,ncommun,nspp),
break1=rep(1,nuni-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1),
phi=matrix(0,ncommun,nspp),
break1=rep(0,nuni-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
tmp=sample.vlk(param,jump1$vlk)
accept1$vlk=accept1$vlk+tmp$accept
param$vlk=tmp$vlk
param$theta=convertVtoTheta(param$vlk,ones.nloc)
# param$theta=theta.true
tmp=sample.phi(param,jump1$phi)
accept1$phi=accept1$phi+tmp$accept
param$phi=tmp$phi
# param$phi=phi.true
tmp=sample.break(param,jump1$break1)
accept1$break1=accept1$break1+tmp$accept
param$break1=tmp$break1
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=10
gamma=0.1
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=-2,to=2,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
for (i in 1:nuni){
cond=dat==uni[i]
indicator[[i]]=which(cond)
}
#gibbs stuff
ngibbs=10000
accept.output=50
vec.theta=matrix(NA,ngibbs,nloc*ncommun)
vec.phi=matrix(NA,ngibbs,ncommun*nspp)
vec.break1=matrix(NA,ngibbs,nuni-1)
jump1=list(vlk=matrix(1,nloc,ncommun-1),
phi=matrix(1,ncommun,nspp),
break1=rep(1,nuni-1))
accept1=list(vlk=matrix(0,nloc,ncommun-1),
phi=matrix(0,ncommun,nspp),
break1=rep(0,nuni-1))
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1)
#core MCMC algorithm
options(warn=2)
for (i in 1:ngibbs){
print(i)
tmp=sample.vlk(param,jump1$vlk)
accept1$vlk=accept1$vlk+tmp$accept
param$vlk=tmp$vlk
param$theta=convertVtoTheta(param$vlk,ones.nloc)
# param$theta=theta.true
tmp=sample.phi(param,jump1$phi)
accept1$phi=accept1$phi+tmp$accept
param$phi=tmp$phi
# param$phi=phi.true
tmp=sample.break(param,jump1$break1)
accept1$break1=accept1$break1+tmp$accept
param$break1=tmp$break1
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.theta[i,]=param$theta
vec.phi[i,]=param$phi
vec.break1[i,]=param$break1
}
seq1=(ngibbs*0.9):ngibbs
theta.estim=matrix(colMeans(vec.theta[seq1,]),nloc,ncommun)
boxplot(theta.estim)
seq.comm=1:5
# seq.comm=c(2,5,3,1,4)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:5){
lines(1:nloc,theta.estim1[,i],col=i)
}
