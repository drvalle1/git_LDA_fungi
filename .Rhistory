teste
#calculate probabilities
medias=theta%*%phi; dim(medias)
z.true=z=matrix(rnorm(nloc*nspp,mean=medias,sd=1),nloc,nspp)
#generate actual observations y
range(z)
break1.true=break1=c(-Inf,seq(from=0,to=6,by=0.1),Inf)
y=matrix(NA,nloc,nspp)
for (i in 2:length(break1)){
cond=z>break1[i-1] & z<break1[i]
y[cond]=i-2
}
tmp=table(y); tmp; length(tmp); length(break1)
setwd('U:\\GIT_models\\git_LDA_fungi')
write.csv(y,'fake data.csv',row.names=F)
rm(list=ls(all=TRUE))
set.seed(6)
library('Rcpp')
# library('MCMCpack')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
thetas.p.lprob=read.csv('potential thetas lprob.csv',as.is=T)$x
thetas.pot=data.matrix(read.csv('potential thetas.csv',as.is=T))
dat=data.matrix(read.csv('fake data.csv',as.is=T))
ngibbs=1000
ncomm.max=ncol(thetas.pot); ncomm.max
prop.burn=0.9
rm(list=ls(all=TRUE))
set.seed(6)
library('Rcpp')
# library('MCMCpack')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
thetas.p.lprob=read.csv('potential thetas lprob.csv',as.is=T)$x
thetas.pot=data.matrix(read.csv('potential thetas.csv',as.is=T))
rm(list=ls(all=TRUE))
set.seed(6)
library('Rcpp')
# library('MCMCpack')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
# thetas.p.lprob=read.csv('potential thetas lprob.csv',as.is=T)$x
thetas.pot=data.matrix(read.csv('potential thetas4.csv',as.is=T))
dat=data.matrix(read.csv('fake data.csv',as.is=T))
ngibbs=1000
ncomm.max=ncol(thetas.pot); ncomm.max
prop.burn=0.9
rm(list=ls(all=TRUE))
set.seed(6)
library('Rcpp')
# library('MCMCpack')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
# thetas.p.lprob=read.csv('potential thetas lprob.csv',as.is=T)$x
thetas.pot=data.matrix(read.csv('potential thetas4.csv',as.is=T))
dat=data.matrix(read.csv('fake data.csv',as.is=T))
ngibbs=1000
ncomm.max=ncol(thetas.pot); ncomm.max
prop.burn=0.9
res=LDA_ordinal(dat=dat,ncomm.max=ncomm.max,ngibbs=ngibbs,prop.burn=prop.burn,
thetas.p.lprob=thetas.p.lprob,thetas.pot=thetas.pot)
rm(list=ls(all=TRUE))
set.seed(6)
library('Rcpp')
# library('MCMCpack')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
# thetas.p.lprob=read.csv('potential thetas lprob.csv',as.is=T)$x
thetas.pot=data.matrix(read.csv('potential thetas4.csv',as.is=T))
dat=data.matrix(read.csv('fake data.csv',as.is=T))
ngibbs=1000
ncomm.max=ncol(thetas.pot); ncomm.max
prop.burn=0.9
res=LDA_ordinal(dat=dat,ncomm.max=ncomm.max,ngibbs=ngibbs,prop.burn=prop.burn,
thetas.p.lprob=thetas.p.lprob,thetas.pot=thetas.pot)
rm(list=ls(all=TRUE))
set.seed(6)
library('Rcpp')
# library('MCMCpack')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
# thetas.p.lprob=read.csv('potential thetas lprob.csv',as.is=T)$x
thetas.pot=data.matrix(read.csv('potential thetas4.csv',as.is=T))
dat=data.matrix(read.csv('fake data.csv',as.is=T))
ngibbs=1000
ncomm.max=ncol(thetas.pot); ncomm.max
prop.burn=0.9
res=LDA_ordinal(dat=dat,ncomm.max=ncomm.max,ngibbs=ngibbs,prop.burn=prop.burn,
thetas.pot=thetas.pot)#,thetas.p.lprob=thetas.p.lprob,
nloc=nrow(dat)
nspp=ncol(dat)
#look at logl
seq1=1:ngibbs
seq1=(ngibbs*0.8):ngibbs
plot(res$logl[seq1],type='l')
ncomm.max
theta.estim=matrix(colMeans(res$theta),nloc,ncomm.max)
boxplot(theta.estim)
seq.comm=1:4
# seq.comm=c(4,2,1)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:length(seq.comm)){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=c(1,3,2,4)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:length(seq.comm)){
lines(1:nloc,theta.estim1[,i],col=i)
}
set.seed(101)
nloc=100
nspp=200
ncommun=4
base=floor(nloc/(ncommun-1))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
#match thetas to potential thetas
setwd('U:\\GIT_models\\git_LDA_fungi')
nome=paste0('potential thetas',ncommun,'.csv')
thetas.pot=data.matrix(read.csv(nome,as.is=T))
for (i in 1:nloc){
theta.mat=matrix(theta[i,],nrow(thetas.pot),ncommun,byrow=T) #watch out for zeroes that are added
sse=rowSums((theta.mat-thetas.pot)^2)
ind=which(sse==min(sse))
theta[i,]=thetas.pot[ind,]
}
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
phi=matrix(NA,ncommun,nspp)
mu.large=6
mu.small=2
ind=matrix(rbinom(ncommun*nspp,size=1,prob=0.2),ncommun,nspp)
for (i in 1:ncommun){
ind1=ind[i,]
cond=ind1==1
tmp=rep(NA,nspp)
tmp[cond ]=rnorm(sum( cond),mean=mu.large,sd=1)
tmp[!cond]=rnorm(sum(!cond),mean=mu.small,sd=1)
phi[i,]=tmp
}
image(phi)
phi.true=phi
#how many unique species does each community have?
teste=rep(0,ncommun)
for (i in 1:nspp){
tmp=ind[,i]
if (sum(tmp)==1){
ind1=which(tmp==1)
teste[ind1]=teste[ind1]+1
}
}
teste
#calculate probabilities
medias=theta%*%phi; dim(medias)
z.true=z=matrix(rnorm(nloc*nspp,mean=medias,sd=1),nloc,nspp)
#generate actual observations y
range(z)
break1.true=break1=c(-Inf,seq(from=0,to=6,by=0.1),Inf)
y=matrix(NA,nloc,nspp)
for (i in 2:length(break1)){
cond=z>break1[i-1] & z<break1[i]
y[cond]=i-2
}
tmp=table(y); tmp; length(tmp); length(break1)
phi.estim=matrix(colMeans(res$phi),ncomm.max,nspp)[seq.comm,]
rango=range(phi.estim,phi.true)
plot(phi.true,phi.estim,ylim=rango,xlim=rango)
lines(rango,rango)
break2=break1.true[-c(1,length(break1.true))]
break.estim=colMeans(res$break1)
rango=range(break.estim,break2)
plot(break2,break.estim,xlim=rango,ylim=rango)
lines(rango,rango,col='red')
lines(rango,rango)
break1.true
break.estim
head(theta.true)
rm(list=ls(all=TRUE))
seq1=seq(from=0,to=1,length.out=21); seq1
rm(list=ls(all=TRUE))
seq1=seq(from=0,to=1,length.out=42); seq1
rm(list=ls(all=TRUE))
seq1=seq(from=0,to=1,length.out=41); seq1
rm(list=ls(all=TRUE))
seq1=seq(from=0,to=1,length.out=41); seq1
#generate thetas for 3 groups
for (ncomm in 2:5){
if (ncomm==2) combo=data.frame(x1=seq1)
if (ncomm==3) combo=expand.grid(x1=seq1,x2=seq1)
if (ncomm==4) combo=expand.grid(x1=seq1,x2=seq1,x3=seq1)
if (ncomm==5) combo=expand.grid(x1=seq1,x2=seq1,x3=seq1,x4=seq1)
soma=rowSums(combo)
combo$fim=1-soma
cond=combo$fim >= 0
combo1=combo[cond,]; dim(combo);
print(c(ncomm,dim(combo1)))
#output results
colnames(combo1)=paste0('theta',1:ncomm)
nome=paste0('potential thetas',ncomm,'.csv')
setwd('U:\\GIT_models\\git_LDA_fungi')
write.csv(combo1,nome,row.names=F)
}
rm(list=ls(all=TRUE))
set.seed(101)
nloc=100
nspp=200
ncommun=4
base=floor(nloc/(ncommun-1))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
#match thetas to potential thetas
setwd('U:\\GIT_models\\git_LDA_fungi')
nome=paste0('potential thetas',ncommun,'.csv')
thetas.pot=data.matrix(read.csv(nome,as.is=T))
for (i in 1:nloc){
theta.mat=matrix(theta[i,],nrow(thetas.pot),ncommun,byrow=T) #watch out for zeroes that are added
sse=rowSums((theta.mat-thetas.pot)^2)
ind=which(sse==min(sse))
theta[i,]=thetas.pot[ind,]
}
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
phi=matrix(NA,ncommun,nspp)
mu.large=6
mu.small=2
ind=matrix(rbinom(ncommun*nspp,size=1,prob=0.2),ncommun,nspp)
for (i in 1:ncommun){
ind1=ind[i,]
cond=ind1==1
tmp=rep(NA,nspp)
tmp[cond ]=rnorm(sum( cond),mean=mu.large,sd=1)
tmp[!cond]=rnorm(sum(!cond),mean=mu.small,sd=1)
phi[i,]=tmp
}
image(phi)
phi.true=phi
#how many unique species does each community have?
teste=rep(0,ncommun)
for (i in 1:nspp){
tmp=ind[,i]
if (sum(tmp)==1){
ind1=which(tmp==1)
teste[ind1]=teste[ind1]+1
}
}
teste
#calculate probabilities
medias=theta%*%phi; dim(medias)
z.true=z=matrix(rnorm(nloc*nspp,mean=medias,sd=1),nloc,nspp)
#generate actual observations y
range(z)
break1.true=break1=c(-Inf,seq(from=0,to=6,by=0.1),Inf)
y=matrix(NA,nloc,nspp)
for (i in 2:length(break1)){
cond=z>break1[i-1] & z<break1[i]
y[cond]=i-2
}
tmp=table(y); tmp; length(tmp); length(break1)
setwd('U:\\GIT_models\\git_LDA_fungi')
write.csv(y,'fake data.csv',row.names=F)
rm(list=ls(all=TRUE))
set.seed(991)
nloc=100
nspp=200
ncommun=4
base=floor(nloc/(ncommun-1))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
#match thetas to potential thetas
setwd('U:\\GIT_models\\git_LDA_fungi')
nome=paste0('potential thetas',ncommun,'.csv')
thetas.pot=data.matrix(read.csv(nome,as.is=T))
for (i in 1:nloc){
theta.mat=matrix(theta[i,],nrow(thetas.pot),ncommun,byrow=T) #watch out for zeroes that are added
sse=rowSums((theta.mat-thetas.pot)^2)
ind=which(sse==min(sse))
theta[i,]=thetas.pot[ind,]
}
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
phi=matrix(NA,ncommun,nspp)
mu.large=6
mu.small=2
ind=matrix(rbinom(ncommun*nspp,size=1,prob=0.2),ncommun,nspp)
for (i in 1:ncommun){
ind1=ind[i,]
cond=ind1==1
tmp=rep(NA,nspp)
tmp[cond ]=rnorm(sum( cond),mean=mu.large,sd=1)
tmp[!cond]=rnorm(sum(!cond),mean=mu.small,sd=1)
phi[i,]=tmp
}
image(phi)
phi.true=phi
#how many unique species does each community have?
teste=rep(0,ncommun)
for (i in 1:nspp){
tmp=ind[,i]
if (sum(tmp)==1){
ind1=which(tmp==1)
teste[ind1]=teste[ind1]+1
}
}
teste
#calculate probabilities
medias=theta%*%phi; dim(medias)
z.true=z=matrix(rnorm(nloc*nspp,mean=medias,sd=1),nloc,nspp)
#generate actual observations y
range(z)
break1.true=break1=c(-Inf,seq(from=0,to=6,by=0.1),Inf)
y=matrix(NA,nloc,nspp)
for (i in 2:length(break1)){
cond=z>break1[i-1] & z<break1[i]
y[cond]=i-2
}
tmp=table(y); tmp; length(tmp); length(break1)
setwd('U:\\GIT_models\\git_LDA_fungi')
write.csv(y,'fake data.csv',row.names=F)
rm(list=ls(all=TRUE))
set.seed(6)
library('Rcpp')
# library('MCMCpack')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
# thetas.p.lprob=read.csv('potential thetas lprob.csv',as.is=T)$x
thetas.pot=data.matrix(read.csv('potential thetas4.csv',as.is=T))
dat=data.matrix(read.csv('fake data.csv',as.is=T))
ngibbs=1000
ncomm.max=ncol(thetas.pot); ncomm.max
prop.burn=0.9
res=LDA_ordinal(dat=dat,ncomm.max=ncomm.max,ngibbs=ngibbs,prop.burn=prop.burn,
thetas.pot=thetas.pot)#,thetas.p.lprob=thetas.p.lprob,
nloc=nrow(dat)
nspp=ncol(dat)
#look at logl
seq1=1:ngibbs
seq1=(ngibbs*0.8):ngibbs
plot(res$logl[seq1],type='l')
theta.estim=matrix(colMeans(res$theta),nloc,ncomm.max)
boxplot(theta.estim)
seq.comm=c(1,3,2,4)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:length(seq.comm)){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=1:4
# seq.comm=c(1,3,2,4)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:length(seq.comm)){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=c(3,1,2,4)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:length(seq.comm)){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=1:4
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:length(seq.comm)){
lines(1:nloc,theta.estim1[,i],col=i)
}
seq.comm=c(4,1,2,3)
theta.estim1=theta.estim[,seq.comm]
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:length(seq.comm)){
lines(1:nloc,theta.estim1[,i],col=i)
}
set.seed(991)
nloc=100
nspp=200
ncommun=4
base=floor(nloc/(ncommun-1))
#generate thetas
x=seq(from=-1,to=1,length.out=base)
y=sqrt(1-(x^2))*0.1
min1=0.0001
y[y<min1]=min1
# plot(x,y)
init=floor(nloc/ncommun)
seq1=c(seq(from=1,to=nloc,by=init),nloc)
theta=matrix(min1,nloc,ncommun)
for (i in 1:ncommun){
seq2=seq1[i]:(seq1[i]+base-1)
seq3=seq2[seq2<=nloc]
theta[seq3,i]=y[1:length(seq3)]
}
theta=theta/matrix(apply(theta,1,sum),nloc,ncommun)
#match thetas to potential thetas
setwd('U:\\GIT_models\\git_LDA_fungi')
nome=paste0('potential thetas',ncommun,'.csv')
thetas.pot=data.matrix(read.csv(nome,as.is=T))
for (i in 1:nloc){
theta.mat=matrix(theta[i,],nrow(thetas.pot),ncommun,byrow=T) #watch out for zeroes that are added
sse=rowSums((theta.mat-thetas.pot)^2)
ind=which(sse==min(sse))
theta[i,]=thetas.pot[ind,]
}
theta.true=theta
plot(NA,NA,xlim=c(0,nloc),ylim=c(0,1))
for (i in 1:ncommun) lines(1:nloc,theta[,i],col=i)
#generate phi
phi=matrix(NA,ncommun,nspp)
mu.large=6
mu.small=2
ind=matrix(rbinom(ncommun*nspp,size=1,prob=0.2),ncommun,nspp)
for (i in 1:ncommun){
ind1=ind[i,]
cond=ind1==1
tmp=rep(NA,nspp)
tmp[cond ]=rnorm(sum( cond),mean=mu.large,sd=1)
tmp[!cond]=rnorm(sum(!cond),mean=mu.small,sd=1)
phi[i,]=tmp
}
image(phi)
phi.true=phi
#how many unique species does each community have?
teste=rep(0,ncommun)
for (i in 1:nspp){
tmp=ind[,i]
if (sum(tmp)==1){
ind1=which(tmp==1)
teste[ind1]=teste[ind1]+1
}
}
teste
#calculate probabilities
medias=theta%*%phi; dim(medias)
z.true=z=matrix(rnorm(nloc*nspp,mean=medias,sd=1),nloc,nspp)
#generate actual observations y
range(z)
break1.true=break1=c(-Inf,seq(from=0,to=6,by=0.1),Inf)
y=matrix(NA,nloc,nspp)
for (i in 2:length(break1)){
cond=z>break1[i-1] & z<break1[i]
y[cond]=i-2
}
tmp=table(y); tmp; length(tmp); length(break1)
phi.estim=matrix(colMeans(res$phi),ncomm.max,nspp)[seq.comm,]
rango=range(phi.estim,phi.true)
plot(phi.true,phi.estim,ylim=rango,xlim=rango)
lines(rango,rango)
#look at breaks
break2=break1.true[-c(1,length(break1.true))]
break.estim=colMeans(res$break1)
rango=range(break.estim,break2)
plot(break2,break.estim,xlim=rango,ylim=rango)
lines(rango,rango,col='red')
lines(rango,rango)
