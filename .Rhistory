# theta[]=rgamma(ncomm,3,10)
# # theta[]=1/ncomm
# theta=theta/sum(theta)
theta=matrix(c(0.5,0.5),2,1)
theta.thetat=theta%*%t(theta)
# phi.x=matrix(rbeta(ncomm,1,1),ncomm,1)
# phi.y=matrix(rbeta(ncomm,1,1),ncomm,1)
phi.x=matrix(c(1,0),2,1)
phi.y=matrix(c(0,1),2,1)
phi.phit=phi.x%*%t(phi.y)
#useful stuff
pred.cov[i]=sum(theta.thetat*phi.phit)-sum(theta*phi.x)*sum(theta*phi.y);
#simulate data
z=rmultinom(nobs.per.loc*2,size=1,prob=theta)
z1=apply(z==1,2,which)
z2=matrix(z1,nobs.per.loc,2)
x=rbinom(nobs.per.loc,size=1,prob=phi.x[z2[,1]])
y=rbinom(nobs.per.loc,size=1,prob=phi.y[z2[,2]])
fim=data.frame(x,y)
obs.cov[i]=var(fim)[1,2]
}
rango=range(c(pred.cov,obs.cov))
plot(pred.cov,obs.cov,xlim=rango,ylim=rango)
lines(rango,rango)
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=10
nspp=2
nsim=10000
nloc=1000
#to store results
pred.cov=rep(NA,nsim)
obs.cov=rep(NA,nsim)
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
apply(theta,1,sum)
phi.x=matrix(c(1,rep(0,ncomm-1)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
j=1
z=rmultinom(nspp,size=1,prob=theta[j,])
z1=apply(z==1,2,which)
z1
z
nspp
theta[j,]
z=rmultinom(nspp,size=1,prob=theta[j,])
z
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
head(z1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z2[,2]])
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=10
nspp=2
nsim=10000
nloc=1000
#to store results
pred.cov=rep(NA,nsim)
obs.cov=rep(NA,nsim)
for (i in 1:nsim){
print(i)
#parameters
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
phi.x=matrix(c(1,rep(0,ncomm-1)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
#simulate data
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i]=cor(fim)[1,2]
}
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=10
nspp=2
nsim=1000
nloc=1000
#to store results
pred.cov=rep(NA,nsim)
obs.cov=rep(NA,nsim)
for (i in 1:nsim){
print(i)
#parameters
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
phi.x=matrix(c(1,rep(0,ncomm-1)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
#simulate data
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i]=cor(fim)[1,2]
}
hist(obs.cov)
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=10
nspp=2
nsim=1000
nloc=1000
#to store results
pred.cov=rep(NA,nsim)
obs.cov=rep(NA,nsim)
for (i in 1:nsim){
print(i)
#parameters
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
phi.x=matrix(c(1,0,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
#simulate data
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i]=cor(fim)[1,2]
}
hist(obs.cov)
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=10
nspp=2
nsim=1000
nloc=1000
#to store results
obs.cov=matrix(NA,nsim,2)
for (i in 1:nsim){
print(i)
#theta parameters
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
#simulate data
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
#phi parameters (negative or small correlation)
phi.x=matrix(c(1,0,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,1]=cor(fim)[1,2]
#phi parameters (negative or small correlation)
phi.x=matrix(c(0.9,0.05,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0.8,0.01,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,2]=cor(fim)[1,2]
}
boxplot(obs.cov)
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=3
nspp=2
nsim=1000
nloc=1000
#to store results
obs.cov=matrix(NA,nsim,2)
for (i in 1:nsim){
print(i)
#theta parameters
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
#simulate data
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
#phi parameters (negative or small correlation)
phi.x=matrix(c(1,0,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,1]=cor(fim)[1,2]
#phi parameters (negative or small correlation)
phi.x=matrix(c(0.9,0.05,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0.8,0.01,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,2]=cor(fim)[1,2]
}
boxplot(obs.cov)
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=3
nspp=2
nsim=1000
nloc=1000
#to store results
obs.cov=matrix(NA,nsim,2)
for (i in 1:nsim){
print(i)
#theta parameters
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
#simulate data
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
#phi parameters (negative or small correlation)
phi.x=matrix(c(1,0,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,1]=cor(fim)[1,2]
#phi parameters (negative or small correlation)
phi.x=matrix(c(0.95,0.05,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0.9,0.01,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,2]=cor(fim)[1,2]
}
boxplot(obs.cov)
rep(0,0)
rm(list=ls(all=TRUE))
set.seed(1)
#settings
ncomm=2
nspp=2
nsim=1000
nloc=1000
#to store results
obs.cov=matrix(NA,nsim,2)
for (i in 1:nsim){
print(i)
#theta parameters
theta=matrix(NA,nloc,ncomm)
theta[]=rgamma(ncomm*nloc,3,10)
theta=theta/apply(theta,1,sum)
#simulate data
z1=matrix(NA,nloc,nspp)
for (j in 1:nloc){
z=rmultinom(nspp,size=1,prob=theta[j,])
z1[j,]=apply(z==1,2,which)
}
#phi parameters (negative or small correlation)
phi.x=matrix(c(1,0,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0,1,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,1]=cor(fim)[1,2]
#phi parameters (negative or small correlation)
phi.x=matrix(c(0.95,0.05,rep(0,ncomm-2)),ncomm,1)
phi.y=matrix(c(0.9,0.01,rep(0,ncomm-2)),ncomm,1)
x=rbinom(nloc,size=1,prob=phi.x[z1[,1]])
y=rbinom(nloc,size=1,prob=phi.y[z1[,2]])
fim=data.frame(x,y)
obs.cov[i,2]=cor(fim)[1,2]
}
boxplot(obs.cov)
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA fungi functions.R')
sourceCpp('aux1.cpp')
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9)
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9)
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9)
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9)
ncomm.max=20
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=ncomm.max
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=0,to=0.1,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
n.indicator=rep(NA,nuni)
z=matrix(NA,nloc,nspp)
for (i in 1:nuni){
cond=dat==uni[i]
ind=which(cond)
indicator[[i]]=ind
z[ind]=i/100
n.indicator[i]=length(ind)
}
#gibbs stuff
accept.output=50
prop.keep=1-prop.burn
vec.theta=matrix(NA,ngibbs*prop.keep,nloc*ncommun)
vec.phi=matrix(NA,ngibbs*prop.keep,ncommun*nspp)
vec.break1=matrix(NA,ngibbs*prop.keep,nuni-1)
vec.logl=matrix(NA,ngibbs,1)
jump1=list(vlk=matrix(1,nloc,ncommun-1),break1=rep(1,nuni-1),break1.sum=0.2,break1.mult=0.05)
accept1=list(vlk=matrix(0,nloc,ncommun-1),break1=rep(0,nuni-1),break1.sum=0,break1.mult=0)
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1,z=z)
#core MCMC algorithm
options(warn=2)
oo=1
for (i in 1:ngibbs){
print(i)
tmp=sample.vlk(param,jump1$vlk,lo.vlk,hi.vlk,ncommun,nloc,gamma,n.vlk)
accept1$vlk=accept1$vlk+tmp$accept
param$vlk=tmp$vlk
param$theta=convertVtoTheta(param$vlk,ones.nloc)
# param$theta=theta.true
param$phi=sample.phi(param)
# param$phi=phi.true
#sample breaks
tmp=sample.break(param,jump1$break1)
accept1$break1=accept1$break1+tmp$accept
param$break1=tmp$break1
tmp=sample.break.sum(param,jump1$break1.sum)
accept1$break1.sum=accept1$break1.sum+tmp$accept
param$break1=tmp$break1
tmp=sample.break.mult(param,jump1$break1.mult)
accept1$break1.mult=accept1$break1.mult+tmp$accept
param$break1=tmp$break1
# param$break1=break1.true[-c(1,length(break1.true))]
param$z=sample.z(param)
# param$z=z.true
#adaptive piece
if (i%%accept.output==0 & i<1000){
k=print.adapt(accept1z=accept1,jump1z=jump1,accept.output=accept.output)
accept1=k$accept1
jump1=k$jump1
}
#store results
vec.logl[i]=get.marg.logl(param$theta,param$phi,param$break1)
if (i>(ngibbs*prop.burn)){
vec.theta[oo,]=param$theta
vec.phi[oo,]=param$phi
vec.break1[oo,]=param$break1
oo=oo+1
}
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9)
ncomm.max=20
nloc=nrow(dat)
nspp=ncol(dat)
ncommun=ncomm.max
uni=sort(unique(as.numeric(dat)))
nuni=length(uni)
#set initial values
vlk=cbind(matrix(0.5,nloc,ncommun-1),1)
phi=matrix(0,ncommun,nspp)
break1=seq(from=0,to=0.1,length.out=nuni-1)
ones.nloc=rep(1,nloc)
theta=convertVtoTheta(vlk,ones.nloc)
ones.nspp=rep(1,nspp)
#things for MH algorithm
n.vlk=(ncommun-1)*nloc
lo.vlk=rep(0,n.vlk)
hi.vlk=rep(1,n.vlk)
n.phi=ncommun*nspp
#useful stuff
indicator=list()
n.indicator=rep(NA,nuni)
z=matrix(NA,nloc,nspp)
for (i in 1:nuni){
cond=dat==uni[i]
ind=which(cond)
indicator[[i]]=ind
z[ind]=i/100
n.indicator[i]=length(ind)
}
jump1=list(vlk=matrix(1,nloc,ncommun-1),break1=rep(1,nuni-1),break1.sum=0.2,break1.mult=0.05)
accept1=list(vlk=matrix(0,nloc,ncommun-1),break1=rep(0,nuni-1),break1.sum=0,break1.mult=0)
param=list(theta=theta,phi=phi,vlk=vlk,break1=break1,z=z)
#core MCMC algorithm
options(warn=2)
oo=1
tmp=sample.vlk(param,jump1$vlk,lo.vlk,hi.vlk,ncommun,nloc,gamma,n.vlk)
ncommun
gamma
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9,gamma=0.1)
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9,gamma=0.1)
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9,gamma=0.1)
rm(list=ls(all=TRUE))
set.seed(4)
library('Rcpp')
setwd('U:\\GIT_models\\git_LDA_fungi')
source('gibbs LDA ordinal aux.R')
source('gibbs LDA ordinal function.R')
sourceCpp('LDA_ordinal_rcpp.cpp')
dat=data.matrix(read.csv('fake data5.csv',as.is=T))
res=LDA_ordinal(dat=dat,ncomm.max=20,ngibbs=10000,prop.burn=0.9,gamma=0.1)
